using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;

namespace MaterialDesignIconsEnum
{
    class Program
    {
        private static bool OptionHelp;
        private static string OptionInputPath;
        private static string OptionOutputPath;

        static void Main(string[] args)
        {
            if (System.Diagnostics.Debugger.IsAttached)
            {
                SafeMain(args);
            }
            else
            {
                try
                {
                    SafeMain(args);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                }
            }
        }

        static void SafeMain(string[] args)
        {
            Console.WriteLine("MaterialDesignIconsEnum - Version 1.1.0 Copyright (C) Simon Mourier 2016-" + DateTime.Now.Year + ". All rights reserved.");
            Console.WriteLine("");

            OptionHelp = CommandLineUtilities.GetArgument("?", false);
            OptionInputPath = CommandLineUtilities.GetArgument<string>(0, null);
            OptionOutputPath = CommandLineUtilities.GetArgument(1, "MaterialDesignIcons.cs");

            if (OptionHelp || Environment.GetCommandLineArgs().Length == 1)
            {
                Console.WriteLine("Format is MaterialDesignIconsEnum.exe <materialdesignicons.less input file path> <output .cs file>");
                Console.WriteLine("");
                return;
            }

            Console.WriteLine("Input file path: " + OptionInputPath);
            Console.WriteLine("Output file path: " + OptionOutputPath);
            bool noStrings = CommandLineUtilities.GetArgument("nostrings", false);
            bool noChars = CommandLineUtilities.GetArgument("nochars", false);
            bool noEnums = CommandLineUtilities.GetArgument("noenums", false);

            if (noChars && noStrings && noChars)
            {
                Console.WriteLine("Duh... Nothing was generated, as requested.");
                return;
            }

            var enums = new List<Tuple<string, string, string>>();
            using (var reader = new StreamReader(OptionInputPath, Encoding.Default))
            {
                do
                {
                    string line = reader.ReadLine();
                    if (line == null)
                        break;

                    const string mdiToken = ".mdi-";
                    line = line.Trim();
                    if (!line.StartsWith(mdiToken))
                        continue;

                    int nameEndPos = line.IndexOf(":before", mdiToken.Length + 1);
                    if (nameEndPos < 0)
                        continue;

                    string nextLine = reader.ReadLine();
                    if (nextLine == null)
                        break;

                    const string contentToken = "content:";
                    int contentPos = nextLine.IndexOf(contentToken);
                    if (contentPos < 0)
                        continue;

                    int valuePos = nextLine.IndexOf("\"\\");
                    if (valuePos < 0)
                        continue;

                    int endValuePos = nextLine.IndexOf('"', valuePos + 1);
                    if (endValuePos < 0)
                        continue;

                    string value = nextLine.Substring(valuePos + 2, endValuePos - (valuePos + 2));
                    string varName = line.Substring(mdiToken.Length, nameEndPos - mdiToken.Length);
                    string name = Camel(line.Substring(mdiToken.Length, nameEndPos - mdiToken.Length));
                    enums.Add(new Tuple<string, string, string>(name, value, varName));
                }
                while (true);
            }

            Console.WriteLine();
            if (enums.Count == 0)
            {
                Console.WriteLine("No variable was found.");
                return;
            }
            Console.WriteLine("Variables detected: " + enums.Count);

            Console.WriteLine();
            using (var iw = new StreamWriter(OptionOutputPath, false))
            {
                var writer = new IndentedTextWriter(iw);
                writer.WriteLine("//------------------------------------------------------------------------------");
                writer.WriteLine("// <auto-generated>");
                writer.WriteLine("//     This code was generated by a tool.");
                writer.WriteLine("//     Runtime Version:" + Environment.Version);
                writer.WriteLine("//");
                writer.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
                writer.WriteLine("//     the code is regenerated.");
                writer.WriteLine("// </auto-generated>");
                writer.WriteLine("//------------------------------------------------------------------------------");
                writer.WriteLine();

                writer.WriteLine("namespace MaterialDesignIcons");
                writer.WriteLine("{");

                if (!noEnums)
                {
                    writer.Indent++;
                    writer.WriteLine("/// <summary>");
                    writer.WriteLine("/// Material Design Icons Resources.");
                    writer.WriteLine("/// </summary>");
                    writer.WriteLine("public enum MaterialDesignIconsEnum");
                    writer.WriteLine("{");
                    for (int i = 0; i < enums.Count; i++)
                    {
                        writer.Indent++;
                        var kv = enums[i];
                        writer.WriteLine("/// <summary>");
                        writer.WriteLine("/// " + kv.Item3 + " glyph (" + kv.Item2 + ").");
                        writer.WriteLine("/// </summary>");
                        writer.Write(GetValidIdentifier(kv.Item1));
                        writer.Write(" = 0x");
                        writer.Write(kv.Item2);
                        if (i < (enums.Count - 1))
                        {
                            writer.WriteLine(',');
                        }
                        writer.WriteLine();
                        writer.Indent--;
                    }
                    writer.WriteLine("}");
                    writer.Indent--;
                }

                if (!noChars)
                {
                    if (!noEnums)
                    {
                        writer.WriteLine("");
                    }
                    writer.Indent++;
                    writer.WriteLine("/// <summary>");
                    writer.WriteLine("/// Material Design Icons Resources.");
                    writer.WriteLine("/// </summary>");
                    writer.WriteLine("public static partial class MaterialDesignCharIcons");
                    writer.WriteLine("{");
                    for (int i = 0; i < enums.Count; i++)
                    {
                        writer.Indent++;
                        var kv = enums[i];
                        writer.WriteLine("/// <summary>");
                        writer.WriteLine("/// " + kv.Item3 + " glyph (" + kv.Item2 + ").");
                        writer.WriteLine("/// </summary>");
                        writer.WriteLine("public const char " + GetValidIdentifier(kv.Item1) + " = '\\u" + kv.Item2 + "';");
                        if (i < (enums.Count - 1))
                        {
                            writer.WriteLine();
                        }
                        writer.Indent--;
                    }
                    writer.WriteLine("}");
                    writer.Indent--;
                }

                if (!noStrings)
                {
                    if (!noEnums || !noChars)
                    {
                        writer.WriteLine("");
                    }
                    writer.Indent++;
                    writer.WriteLine("/// <summary>");
                    writer.WriteLine("/// Material Design Icons Strings.");
                    writer.WriteLine("/// </summary>");
                    writer.WriteLine("public static partial class MaterialDesignStringIcons");
                    writer.WriteLine("{");
                    for (int i = 0; i < enums.Count; i++)
                    {
                        writer.Indent++;
                        var kv = enums[i];
                        writer.WriteLine("/// <summary>");
                        writer.WriteLine("/// " + kv.Item3 + " glyph (" + kv.Item2 + ").");
                        writer.WriteLine("/// </summary>");
                        writer.WriteLine("public const string " + GetValidIdentifier(kv.Item1) + " = \"\\u" + kv.Item2 + "\";");
                        if (i < (enums.Count - 1))
                        {
                            writer.WriteLine();
                        }
                        writer.Indent--;
                    }
                    writer.WriteLine("}");
                    writer.Indent--;
                }

                writer.Indent--;
                writer.WriteLine("}");
            }
            Console.WriteLine("Output file was successfully written.");
        }

        static string Camel(string s)
        {
            if (s == null)
                return s;

            var sb = new StringBuilder(s.Length);
            bool next = false;
            for (int i = 0; i < s.Length; i++)
            {
                if (i == 0)
                {
                    sb.Append(char.ToUpper(s[i]));
                    continue;
                }

                if (s[i] == '-')
                {
                    next = true;
                    continue;
                }

                if (next)
                {
                    sb.Append(char.ToUpper(s[i]));
                    next = false;
                }
                else
                {
                    sb.Append(s[i]);
                }
            }
            return sb.ToString();
        }

        static string GetValidIdentifier(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
                throw new ArgumentNullException(nameof(text));

            int start = 0;
            var sb = new StringBuilder(text.Length);
            if (IsValidIdentifierStart(text[0]))
            {
                sb.Append(text[0]);
                start = 1;
            }
            else
            {
                sb.Append('_');
            }

            bool nextUpper = false;
            for (int i = start; i < text.Length; i++)
            {
                if (IsValidIdentifierPart(text[i]))
                {
                    if (nextUpper)
                    {
                        sb.Append(char.ToUpper(text[i], CultureInfo.CurrentCulture));
                        nextUpper = false;
                    }
                    else
                    {
                        sb.Append(text[i]);
                    }
                }
                else
                {
                    if (text[i] == ' ')
                    {
                        nextUpper = true;
                    }
                    else
                    {
                        sb.Append('_');
                    }
                }
            }
            return sb.ToString();
        }

        static bool IsValidIdentifierStart(char character)
        {
            if (character == '_')
                return true;

            var category = CharUnicodeInfo.GetUnicodeCategory(character);
            switch (category)
            {
                case UnicodeCategory.UppercaseLetter://Lu
                case UnicodeCategory.LowercaseLetter://Ll
                case UnicodeCategory.TitlecaseLetter://Lt
                case UnicodeCategory.ModifierLetter://Lm
                case UnicodeCategory.OtherLetter://Lo
                case UnicodeCategory.LetterNumber://Nl
                    return true;

                default:
                    return false;
            }
        }

        static bool IsValidIdentifierPart(char character)
        {
            var category = CharUnicodeInfo.GetUnicodeCategory(character);
            switch (category)
            {
                case UnicodeCategory.UppercaseLetter:
                case UnicodeCategory.LowercaseLetter:
                case UnicodeCategory.TitlecaseLetter:
                case UnicodeCategory.ModifierLetter:
                case UnicodeCategory.LetterNumber:
                case UnicodeCategory.NonSpacingMark:
                case UnicodeCategory.SpacingCombiningMark:
                case UnicodeCategory.DecimalDigitNumber:
                case UnicodeCategory.ConnectorPunctuation:
                case UnicodeCategory.Format:
                    return true;

                default:
                    return false;
            }
        }
    }
}
